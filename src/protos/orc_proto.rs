// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `orc_proto.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct IntegerStatistics {
    // message fields
    minimum: ::std::option::Option<i64>,
    maximum: ::std::option::Option<i64>,
    sum: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IntegerStatistics {
    fn default() -> &'a IntegerStatistics {
        <IntegerStatistics as ::protobuf::Message>::default_instance()
    }
}

impl IntegerStatistics {
    pub fn new() -> IntegerStatistics {
        ::std::default::Default::default()
    }

    // optional sint64 minimum = 1;


    pub fn get_minimum(&self) -> i64 {
        self.minimum.unwrap_or(0)
    }
    pub fn clear_minimum(&mut self) {
        self.minimum = ::std::option::Option::None;
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: i64) {
        self.minimum = ::std::option::Option::Some(v);
    }

    // optional sint64 maximum = 2;


    pub fn get_maximum(&self) -> i64 {
        self.maximum.unwrap_or(0)
    }
    pub fn clear_maximum(&mut self) {
        self.maximum = ::std::option::Option::None;
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: i64) {
        self.maximum = ::std::option::Option::Some(v);
    }

    // optional sint64 sum = 3;


    pub fn get_sum(&self) -> i64 {
        self.sum.unwrap_or(0)
    }
    pub fn clear_sum(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_sum(&self) -> bool {
        self.sum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: i64) {
        self.sum = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for IntegerStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.minimum = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.maximum = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.sum = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.minimum {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
        }
        if let Some(v) = self.maximum {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
        }
        if let Some(v) = self.sum {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.minimum {
            os.write_sint64(1, v)?;
        }
        if let Some(v) = self.maximum {
            os.write_sint64(2, v)?;
        }
        if let Some(v) = self.sum {
            os.write_sint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IntegerStatistics {
        IntegerStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "minimum",
                |m: &IntegerStatistics| { &m.minimum },
                |m: &mut IntegerStatistics| { &mut m.minimum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "maximum",
                |m: &IntegerStatistics| { &m.maximum },
                |m: &mut IntegerStatistics| { &mut m.maximum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "sum",
                |m: &IntegerStatistics| { &m.sum },
                |m: &mut IntegerStatistics| { &mut m.sum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IntegerStatistics>(
                "IntegerStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IntegerStatistics {
        static instance: ::protobuf::rt::LazyV2<IntegerStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IntegerStatistics::new)
    }
}

impl ::protobuf::Clear for IntegerStatistics {
    fn clear(&mut self) {
        self.minimum = ::std::option::Option::None;
        self.maximum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IntegerStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IntegerStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DoubleStatistics {
    // message fields
    minimum: ::std::option::Option<f64>,
    maximum: ::std::option::Option<f64>,
    sum: ::std::option::Option<f64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DoubleStatistics {
    fn default() -> &'a DoubleStatistics {
        <DoubleStatistics as ::protobuf::Message>::default_instance()
    }
}

impl DoubleStatistics {
    pub fn new() -> DoubleStatistics {
        ::std::default::Default::default()
    }

    // optional double minimum = 1;


    pub fn get_minimum(&self) -> f64 {
        self.minimum.unwrap_or(0.)
    }
    pub fn clear_minimum(&mut self) {
        self.minimum = ::std::option::Option::None;
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: f64) {
        self.minimum = ::std::option::Option::Some(v);
    }

    // optional double maximum = 2;


    pub fn get_maximum(&self) -> f64 {
        self.maximum.unwrap_or(0.)
    }
    pub fn clear_maximum(&mut self) {
        self.maximum = ::std::option::Option::None;
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: f64) {
        self.maximum = ::std::option::Option::Some(v);
    }

    // optional double sum = 3;


    pub fn get_sum(&self) -> f64 {
        self.sum.unwrap_or(0.)
    }
    pub fn clear_sum(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_sum(&self) -> bool {
        self.sum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: f64) {
        self.sum = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DoubleStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.minimum = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.maximum = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.sum = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.minimum {
            my_size += 9;
        }
        if let Some(v) = self.maximum {
            my_size += 9;
        }
        if let Some(v) = self.sum {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.minimum {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.maximum {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.sum {
            os.write_double(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DoubleStatistics {
        DoubleStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "minimum",
                |m: &DoubleStatistics| { &m.minimum },
                |m: &mut DoubleStatistics| { &mut m.minimum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "maximum",
                |m: &DoubleStatistics| { &m.maximum },
                |m: &mut DoubleStatistics| { &mut m.maximum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "sum",
                |m: &DoubleStatistics| { &m.sum },
                |m: &mut DoubleStatistics| { &mut m.sum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DoubleStatistics>(
                "DoubleStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DoubleStatistics {
        static instance: ::protobuf::rt::LazyV2<DoubleStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DoubleStatistics::new)
    }
}

impl ::protobuf::Clear for DoubleStatistics {
    fn clear(&mut self) {
        self.minimum = ::std::option::Option::None;
        self.maximum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DoubleStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoubleStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringStatistics {
    // message fields
    minimum: ::protobuf::SingularField<::std::string::String>,
    maximum: ::protobuf::SingularField<::std::string::String>,
    sum: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringStatistics {
    fn default() -> &'a StringStatistics {
        <StringStatistics as ::protobuf::Message>::default_instance()
    }
}

impl StringStatistics {
    pub fn new() -> StringStatistics {
        ::std::default::Default::default()
    }

    // optional string minimum = 1;


    pub fn get_minimum(&self) -> &str {
        match self.minimum.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_minimum(&mut self) {
        self.minimum.clear();
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: ::std::string::String) {
        self.minimum = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minimum(&mut self) -> &mut ::std::string::String {
        if self.minimum.is_none() {
            self.minimum.set_default();
        }
        self.minimum.as_mut().unwrap()
    }

    // Take field
    pub fn take_minimum(&mut self) -> ::std::string::String {
        self.minimum.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string maximum = 2;


    pub fn get_maximum(&self) -> &str {
        match self.maximum.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_maximum(&mut self) {
        self.maximum.clear();
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: ::std::string::String) {
        self.maximum = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maximum(&mut self) -> &mut ::std::string::String {
        if self.maximum.is_none() {
            self.maximum.set_default();
        }
        self.maximum.as_mut().unwrap()
    }

    // Take field
    pub fn take_maximum(&mut self) -> ::std::string::String {
        self.maximum.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sint64 sum = 3;


    pub fn get_sum(&self) -> i64 {
        self.sum.unwrap_or(0)
    }
    pub fn clear_sum(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_sum(&self) -> bool {
        self.sum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: i64) {
        self.sum = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StringStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.minimum)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.maximum)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.sum = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.minimum.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.maximum.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.sum {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.minimum.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.maximum.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.sum {
            os.write_sint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringStatistics {
        StringStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "minimum",
                |m: &StringStatistics| { &m.minimum },
                |m: &mut StringStatistics| { &mut m.minimum },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "maximum",
                |m: &StringStatistics| { &m.maximum },
                |m: &mut StringStatistics| { &mut m.maximum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "sum",
                |m: &StringStatistics| { &m.sum },
                |m: &mut StringStatistics| { &mut m.sum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringStatistics>(
                "StringStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StringStatistics {
        static instance: ::protobuf::rt::LazyV2<StringStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringStatistics::new)
    }
}

impl ::protobuf::Clear for StringStatistics {
    fn clear(&mut self) {
        self.minimum.clear();
        self.maximum.clear();
        self.sum = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BucketStatistics {
    // message fields
    pub count: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BucketStatistics {
    fn default() -> &'a BucketStatistics {
        <BucketStatistics as ::protobuf::Message>::default_instance()
    }
}

impl BucketStatistics {
    pub fn new() -> BucketStatistics {
        ::std::default::Default::default()
    }

    // repeated uint64 count = 1;


    pub fn get_count(&self) -> &[u64] {
        &self.count
    }
    pub fn clear_count(&mut self) {
        self.count.clear();
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: ::std::vec::Vec<u64>) {
        self.count = v;
    }

    // Mutable pointer to the field.
    pub fn mut_count(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.count
    }

    // Take field
    pub fn take_count(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.count, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BucketStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.count)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.count.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(1, &self.count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.count.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.count))?;
            for v in &self.count {
                os.write_uint64_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BucketStatistics {
        BucketStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "count",
                |m: &BucketStatistics| { &m.count },
                |m: &mut BucketStatistics| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BucketStatistics>(
                "BucketStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BucketStatistics {
        static instance: ::protobuf::rt::LazyV2<BucketStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BucketStatistics::new)
    }
}

impl ::protobuf::Clear for BucketStatistics {
    fn clear(&mut self) {
        self.count.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BucketStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BucketStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecimalStatistics {
    // message fields
    minimum: ::protobuf::SingularField<::std::string::String>,
    maximum: ::protobuf::SingularField<::std::string::String>,
    sum: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecimalStatistics {
    fn default() -> &'a DecimalStatistics {
        <DecimalStatistics as ::protobuf::Message>::default_instance()
    }
}

impl DecimalStatistics {
    pub fn new() -> DecimalStatistics {
        ::std::default::Default::default()
    }

    // optional string minimum = 1;


    pub fn get_minimum(&self) -> &str {
        match self.minimum.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_minimum(&mut self) {
        self.minimum.clear();
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: ::std::string::String) {
        self.minimum = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minimum(&mut self) -> &mut ::std::string::String {
        if self.minimum.is_none() {
            self.minimum.set_default();
        }
        self.minimum.as_mut().unwrap()
    }

    // Take field
    pub fn take_minimum(&mut self) -> ::std::string::String {
        self.minimum.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string maximum = 2;


    pub fn get_maximum(&self) -> &str {
        match self.maximum.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_maximum(&mut self) {
        self.maximum.clear();
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: ::std::string::String) {
        self.maximum = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maximum(&mut self) -> &mut ::std::string::String {
        if self.maximum.is_none() {
            self.maximum.set_default();
        }
        self.maximum.as_mut().unwrap()
    }

    // Take field
    pub fn take_maximum(&mut self) -> ::std::string::String {
        self.maximum.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sum = 3;


    pub fn get_sum(&self) -> &str {
        match self.sum.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sum(&mut self) {
        self.sum.clear();
    }

    pub fn has_sum(&self) -> bool {
        self.sum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: ::std::string::String) {
        self.sum = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sum(&mut self) -> &mut ::std::string::String {
        if self.sum.is_none() {
            self.sum.set_default();
        }
        self.sum.as_mut().unwrap()
    }

    // Take field
    pub fn take_sum(&mut self) -> ::std::string::String {
        self.sum.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DecimalStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.minimum)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.maximum)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sum)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.minimum.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.maximum.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.sum.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.minimum.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.maximum.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.sum.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecimalStatistics {
        DecimalStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "minimum",
                |m: &DecimalStatistics| { &m.minimum },
                |m: &mut DecimalStatistics| { &mut m.minimum },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "maximum",
                |m: &DecimalStatistics| { &m.maximum },
                |m: &mut DecimalStatistics| { &mut m.maximum },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sum",
                |m: &DecimalStatistics| { &m.sum },
                |m: &mut DecimalStatistics| { &mut m.sum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecimalStatistics>(
                "DecimalStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DecimalStatistics {
        static instance: ::protobuf::rt::LazyV2<DecimalStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DecimalStatistics::new)
    }
}

impl ::protobuf::Clear for DecimalStatistics {
    fn clear(&mut self) {
        self.minimum.clear();
        self.maximum.clear();
        self.sum.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecimalStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecimalStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DateStatistics {
    // message fields
    minimum: ::std::option::Option<i32>,
    maximum: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DateStatistics {
    fn default() -> &'a DateStatistics {
        <DateStatistics as ::protobuf::Message>::default_instance()
    }
}

impl DateStatistics {
    pub fn new() -> DateStatistics {
        ::std::default::Default::default()
    }

    // optional sint32 minimum = 1;


    pub fn get_minimum(&self) -> i32 {
        self.minimum.unwrap_or(0)
    }
    pub fn clear_minimum(&mut self) {
        self.minimum = ::std::option::Option::None;
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: i32) {
        self.minimum = ::std::option::Option::Some(v);
    }

    // optional sint32 maximum = 2;


    pub fn get_maximum(&self) -> i32 {
        self.maximum.unwrap_or(0)
    }
    pub fn clear_maximum(&mut self) {
        self.maximum = ::std::option::Option::None;
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: i32) {
        self.maximum = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DateStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.minimum = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.maximum = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.minimum {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
        }
        if let Some(v) = self.maximum {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.minimum {
            os.write_sint32(1, v)?;
        }
        if let Some(v) = self.maximum {
            os.write_sint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DateStatistics {
        DateStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "minimum",
                |m: &DateStatistics| { &m.minimum },
                |m: &mut DateStatistics| { &mut m.minimum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "maximum",
                |m: &DateStatistics| { &m.maximum },
                |m: &mut DateStatistics| { &mut m.maximum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DateStatistics>(
                "DateStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DateStatistics {
        static instance: ::protobuf::rt::LazyV2<DateStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DateStatistics::new)
    }
}

impl ::protobuf::Clear for DateStatistics {
    fn clear(&mut self) {
        self.minimum = ::std::option::Option::None;
        self.maximum = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DateStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DateStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimestampStatistics {
    // message fields
    minimum: ::std::option::Option<i64>,
    maximum: ::std::option::Option<i64>,
    minimumUtc: ::std::option::Option<i64>,
    maximumUtc: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimestampStatistics {
    fn default() -> &'a TimestampStatistics {
        <TimestampStatistics as ::protobuf::Message>::default_instance()
    }
}

impl TimestampStatistics {
    pub fn new() -> TimestampStatistics {
        ::std::default::Default::default()
    }

    // optional sint64 minimum = 1;


    pub fn get_minimum(&self) -> i64 {
        self.minimum.unwrap_or(0)
    }
    pub fn clear_minimum(&mut self) {
        self.minimum = ::std::option::Option::None;
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: i64) {
        self.minimum = ::std::option::Option::Some(v);
    }

    // optional sint64 maximum = 2;


    pub fn get_maximum(&self) -> i64 {
        self.maximum.unwrap_or(0)
    }
    pub fn clear_maximum(&mut self) {
        self.maximum = ::std::option::Option::None;
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: i64) {
        self.maximum = ::std::option::Option::Some(v);
    }

    // optional sint64 minimumUtc = 3;


    pub fn get_minimumUtc(&self) -> i64 {
        self.minimumUtc.unwrap_or(0)
    }
    pub fn clear_minimumUtc(&mut self) {
        self.minimumUtc = ::std::option::Option::None;
    }

    pub fn has_minimumUtc(&self) -> bool {
        self.minimumUtc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimumUtc(&mut self, v: i64) {
        self.minimumUtc = ::std::option::Option::Some(v);
    }

    // optional sint64 maximumUtc = 4;


    pub fn get_maximumUtc(&self) -> i64 {
        self.maximumUtc.unwrap_or(0)
    }
    pub fn clear_maximumUtc(&mut self) {
        self.maximumUtc = ::std::option::Option::None;
    }

    pub fn has_maximumUtc(&self) -> bool {
        self.maximumUtc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximumUtc(&mut self, v: i64) {
        self.maximumUtc = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TimestampStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.minimum = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.maximum = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.minimumUtc = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.maximumUtc = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.minimum {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
        }
        if let Some(v) = self.maximum {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
        }
        if let Some(v) = self.minimumUtc {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        if let Some(v) = self.maximumUtc {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.minimum {
            os.write_sint64(1, v)?;
        }
        if let Some(v) = self.maximum {
            os.write_sint64(2, v)?;
        }
        if let Some(v) = self.minimumUtc {
            os.write_sint64(3, v)?;
        }
        if let Some(v) = self.maximumUtc {
            os.write_sint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimestampStatistics {
        TimestampStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "minimum",
                |m: &TimestampStatistics| { &m.minimum },
                |m: &mut TimestampStatistics| { &mut m.minimum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "maximum",
                |m: &TimestampStatistics| { &m.maximum },
                |m: &mut TimestampStatistics| { &mut m.maximum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "minimumUtc",
                |m: &TimestampStatistics| { &m.minimumUtc },
                |m: &mut TimestampStatistics| { &mut m.minimumUtc },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "maximumUtc",
                |m: &TimestampStatistics| { &m.maximumUtc },
                |m: &mut TimestampStatistics| { &mut m.maximumUtc },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimestampStatistics>(
                "TimestampStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimestampStatistics {
        static instance: ::protobuf::rt::LazyV2<TimestampStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimestampStatistics::new)
    }
}

impl ::protobuf::Clear for TimestampStatistics {
    fn clear(&mut self) {
        self.minimum = ::std::option::Option::None;
        self.maximum = ::std::option::Option::None;
        self.minimumUtc = ::std::option::Option::None;
        self.maximumUtc = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimestampStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimestampStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BinaryStatistics {
    // message fields
    sum: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BinaryStatistics {
    fn default() -> &'a BinaryStatistics {
        <BinaryStatistics as ::protobuf::Message>::default_instance()
    }
}

impl BinaryStatistics {
    pub fn new() -> BinaryStatistics {
        ::std::default::Default::default()
    }

    // optional sint64 sum = 1;


    pub fn get_sum(&self) -> i64 {
        self.sum.unwrap_or(0)
    }
    pub fn clear_sum(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_sum(&self) -> bool {
        self.sum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: i64) {
        self.sum = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BinaryStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.sum = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sum {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sum {
            os.write_sint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BinaryStatistics {
        BinaryStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "sum",
                |m: &BinaryStatistics| { &m.sum },
                |m: &mut BinaryStatistics| { &mut m.sum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BinaryStatistics>(
                "BinaryStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BinaryStatistics {
        static instance: ::protobuf::rt::LazyV2<BinaryStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BinaryStatistics::new)
    }
}

impl ::protobuf::Clear for BinaryStatistics {
    fn clear(&mut self) {
        self.sum = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BinaryStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BinaryStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ColumnStatistics {
    // message fields
    numberOfValues: ::std::option::Option<u64>,
    pub intStatistics: ::protobuf::SingularPtrField<IntegerStatistics>,
    pub doubleStatistics: ::protobuf::SingularPtrField<DoubleStatistics>,
    pub stringStatistics: ::protobuf::SingularPtrField<StringStatistics>,
    pub bucketStatistics: ::protobuf::SingularPtrField<BucketStatistics>,
    pub decimalStatistics: ::protobuf::SingularPtrField<DecimalStatistics>,
    pub dateStatistics: ::protobuf::SingularPtrField<DateStatistics>,
    pub binaryStatistics: ::protobuf::SingularPtrField<BinaryStatistics>,
    pub timestampStatistics: ::protobuf::SingularPtrField<TimestampStatistics>,
    hasNull: ::std::option::Option<bool>,
    bytesOnDisk: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ColumnStatistics {
    fn default() -> &'a ColumnStatistics {
        <ColumnStatistics as ::protobuf::Message>::default_instance()
    }
}

impl ColumnStatistics {
    pub fn new() -> ColumnStatistics {
        ::std::default::Default::default()
    }

    // optional uint64 numberOfValues = 1;


    pub fn get_numberOfValues(&self) -> u64 {
        self.numberOfValues.unwrap_or(0)
    }
    pub fn clear_numberOfValues(&mut self) {
        self.numberOfValues = ::std::option::Option::None;
    }

    pub fn has_numberOfValues(&self) -> bool {
        self.numberOfValues.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberOfValues(&mut self, v: u64) {
        self.numberOfValues = ::std::option::Option::Some(v);
    }

    // optional .orc.proto.IntegerStatistics intStatistics = 2;


    pub fn get_intStatistics(&self) -> &IntegerStatistics {
        self.intStatistics.as_ref().unwrap_or_else(|| <IntegerStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_intStatistics(&mut self) {
        self.intStatistics.clear();
    }

    pub fn has_intStatistics(&self) -> bool {
        self.intStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_intStatistics(&mut self, v: IntegerStatistics) {
        self.intStatistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_intStatistics(&mut self) -> &mut IntegerStatistics {
        if self.intStatistics.is_none() {
            self.intStatistics.set_default();
        }
        self.intStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_intStatistics(&mut self) -> IntegerStatistics {
        self.intStatistics.take().unwrap_or_else(|| IntegerStatistics::new())
    }

    // optional .orc.proto.DoubleStatistics doubleStatistics = 3;


    pub fn get_doubleStatistics(&self) -> &DoubleStatistics {
        self.doubleStatistics.as_ref().unwrap_or_else(|| <DoubleStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_doubleStatistics(&mut self) {
        self.doubleStatistics.clear();
    }

    pub fn has_doubleStatistics(&self) -> bool {
        self.doubleStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doubleStatistics(&mut self, v: DoubleStatistics) {
        self.doubleStatistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doubleStatistics(&mut self) -> &mut DoubleStatistics {
        if self.doubleStatistics.is_none() {
            self.doubleStatistics.set_default();
        }
        self.doubleStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_doubleStatistics(&mut self) -> DoubleStatistics {
        self.doubleStatistics.take().unwrap_or_else(|| DoubleStatistics::new())
    }

    // optional .orc.proto.StringStatistics stringStatistics = 4;


    pub fn get_stringStatistics(&self) -> &StringStatistics {
        self.stringStatistics.as_ref().unwrap_or_else(|| <StringStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stringStatistics(&mut self) {
        self.stringStatistics.clear();
    }

    pub fn has_stringStatistics(&self) -> bool {
        self.stringStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stringStatistics(&mut self, v: StringStatistics) {
        self.stringStatistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stringStatistics(&mut self) -> &mut StringStatistics {
        if self.stringStatistics.is_none() {
            self.stringStatistics.set_default();
        }
        self.stringStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_stringStatistics(&mut self) -> StringStatistics {
        self.stringStatistics.take().unwrap_or_else(|| StringStatistics::new())
    }

    // optional .orc.proto.BucketStatistics bucketStatistics = 5;


    pub fn get_bucketStatistics(&self) -> &BucketStatistics {
        self.bucketStatistics.as_ref().unwrap_or_else(|| <BucketStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bucketStatistics(&mut self) {
        self.bucketStatistics.clear();
    }

    pub fn has_bucketStatistics(&self) -> bool {
        self.bucketStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bucketStatistics(&mut self, v: BucketStatistics) {
        self.bucketStatistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucketStatistics(&mut self) -> &mut BucketStatistics {
        if self.bucketStatistics.is_none() {
            self.bucketStatistics.set_default();
        }
        self.bucketStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_bucketStatistics(&mut self) -> BucketStatistics {
        self.bucketStatistics.take().unwrap_or_else(|| BucketStatistics::new())
    }

    // optional .orc.proto.DecimalStatistics decimalStatistics = 6;


    pub fn get_decimalStatistics(&self) -> &DecimalStatistics {
        self.decimalStatistics.as_ref().unwrap_or_else(|| <DecimalStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_decimalStatistics(&mut self) {
        self.decimalStatistics.clear();
    }

    pub fn has_decimalStatistics(&self) -> bool {
        self.decimalStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decimalStatistics(&mut self, v: DecimalStatistics) {
        self.decimalStatistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_decimalStatistics(&mut self) -> &mut DecimalStatistics {
        if self.decimalStatistics.is_none() {
            self.decimalStatistics.set_default();
        }
        self.decimalStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_decimalStatistics(&mut self) -> DecimalStatistics {
        self.decimalStatistics.take().unwrap_or_else(|| DecimalStatistics::new())
    }

    // optional .orc.proto.DateStatistics dateStatistics = 7;


    pub fn get_dateStatistics(&self) -> &DateStatistics {
        self.dateStatistics.as_ref().unwrap_or_else(|| <DateStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dateStatistics(&mut self) {
        self.dateStatistics.clear();
    }

    pub fn has_dateStatistics(&self) -> bool {
        self.dateStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dateStatistics(&mut self, v: DateStatistics) {
        self.dateStatistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dateStatistics(&mut self) -> &mut DateStatistics {
        if self.dateStatistics.is_none() {
            self.dateStatistics.set_default();
        }
        self.dateStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_dateStatistics(&mut self) -> DateStatistics {
        self.dateStatistics.take().unwrap_or_else(|| DateStatistics::new())
    }

    // optional .orc.proto.BinaryStatistics binaryStatistics = 8;


    pub fn get_binaryStatistics(&self) -> &BinaryStatistics {
        self.binaryStatistics.as_ref().unwrap_or_else(|| <BinaryStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_binaryStatistics(&mut self) {
        self.binaryStatistics.clear();
    }

    pub fn has_binaryStatistics(&self) -> bool {
        self.binaryStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_binaryStatistics(&mut self, v: BinaryStatistics) {
        self.binaryStatistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_binaryStatistics(&mut self) -> &mut BinaryStatistics {
        if self.binaryStatistics.is_none() {
            self.binaryStatistics.set_default();
        }
        self.binaryStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_binaryStatistics(&mut self) -> BinaryStatistics {
        self.binaryStatistics.take().unwrap_or_else(|| BinaryStatistics::new())
    }

    // optional .orc.proto.TimestampStatistics timestampStatistics = 9;


    pub fn get_timestampStatistics(&self) -> &TimestampStatistics {
        self.timestampStatistics.as_ref().unwrap_or_else(|| <TimestampStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_timestampStatistics(&mut self) {
        self.timestampStatistics.clear();
    }

    pub fn has_timestampStatistics(&self) -> bool {
        self.timestampStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestampStatistics(&mut self, v: TimestampStatistics) {
        self.timestampStatistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timestampStatistics(&mut self) -> &mut TimestampStatistics {
        if self.timestampStatistics.is_none() {
            self.timestampStatistics.set_default();
        }
        self.timestampStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_timestampStatistics(&mut self) -> TimestampStatistics {
        self.timestampStatistics.take().unwrap_or_else(|| TimestampStatistics::new())
    }

    // optional bool hasNull = 10;


    pub fn get_hasNull(&self) -> bool {
        self.hasNull.unwrap_or(false)
    }
    pub fn clear_hasNull(&mut self) {
        self.hasNull = ::std::option::Option::None;
    }

    pub fn has_hasNull(&self) -> bool {
        self.hasNull.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasNull(&mut self, v: bool) {
        self.hasNull = ::std::option::Option::Some(v);
    }

    // optional uint64 bytesOnDisk = 11;


    pub fn get_bytesOnDisk(&self) -> u64 {
        self.bytesOnDisk.unwrap_or(0)
    }
    pub fn clear_bytesOnDisk(&mut self) {
        self.bytesOnDisk = ::std::option::Option::None;
    }

    pub fn has_bytesOnDisk(&self) -> bool {
        self.bytesOnDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesOnDisk(&mut self, v: u64) {
        self.bytesOnDisk = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ColumnStatistics {
    fn is_initialized(&self) -> bool {
        for v in &self.intStatistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.doubleStatistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stringStatistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bucketStatistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.decimalStatistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dateStatistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.binaryStatistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.timestampStatistics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.numberOfValues = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.intStatistics)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.doubleStatistics)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stringStatistics)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bucketStatistics)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.decimalStatistics)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dateStatistics)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.binaryStatistics)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timestampStatistics)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasNull = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytesOnDisk = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.numberOfValues {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.intStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.doubleStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stringStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bucketStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.decimalStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dateStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.binaryStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.timestampStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.hasNull {
            my_size += 2;
        }
        if let Some(v) = self.bytesOnDisk {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.numberOfValues {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.intStatistics.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.doubleStatistics.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stringStatistics.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bucketStatistics.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.decimalStatistics.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dateStatistics.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.binaryStatistics.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.timestampStatistics.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.hasNull {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.bytesOnDisk {
            os.write_uint64(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ColumnStatistics {
        ColumnStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "numberOfValues",
                |m: &ColumnStatistics| { &m.numberOfValues },
                |m: &mut ColumnStatistics| { &mut m.numberOfValues },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IntegerStatistics>>(
                "intStatistics",
                |m: &ColumnStatistics| { &m.intStatistics },
                |m: &mut ColumnStatistics| { &mut m.intStatistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DoubleStatistics>>(
                "doubleStatistics",
                |m: &ColumnStatistics| { &m.doubleStatistics },
                |m: &mut ColumnStatistics| { &mut m.doubleStatistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringStatistics>>(
                "stringStatistics",
                |m: &ColumnStatistics| { &m.stringStatistics },
                |m: &mut ColumnStatistics| { &mut m.stringStatistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BucketStatistics>>(
                "bucketStatistics",
                |m: &ColumnStatistics| { &m.bucketStatistics },
                |m: &mut ColumnStatistics| { &mut m.bucketStatistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DecimalStatistics>>(
                "decimalStatistics",
                |m: &ColumnStatistics| { &m.decimalStatistics },
                |m: &mut ColumnStatistics| { &mut m.decimalStatistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DateStatistics>>(
                "dateStatistics",
                |m: &ColumnStatistics| { &m.dateStatistics },
                |m: &mut ColumnStatistics| { &mut m.dateStatistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BinaryStatistics>>(
                "binaryStatistics",
                |m: &ColumnStatistics| { &m.binaryStatistics },
                |m: &mut ColumnStatistics| { &mut m.binaryStatistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimestampStatistics>>(
                "timestampStatistics",
                |m: &ColumnStatistics| { &m.timestampStatistics },
                |m: &mut ColumnStatistics| { &mut m.timestampStatistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasNull",
                |m: &ColumnStatistics| { &m.hasNull },
                |m: &mut ColumnStatistics| { &mut m.hasNull },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bytesOnDisk",
                |m: &ColumnStatistics| { &m.bytesOnDisk },
                |m: &mut ColumnStatistics| { &mut m.bytesOnDisk },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ColumnStatistics>(
                "ColumnStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ColumnStatistics {
        static instance: ::protobuf::rt::LazyV2<ColumnStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ColumnStatistics::new)
    }
}

impl ::protobuf::Clear for ColumnStatistics {
    fn clear(&mut self) {
        self.numberOfValues = ::std::option::Option::None;
        self.intStatistics.clear();
        self.doubleStatistics.clear();
        self.stringStatistics.clear();
        self.bucketStatistics.clear();
        self.decimalStatistics.clear();
        self.dateStatistics.clear();
        self.binaryStatistics.clear();
        self.timestampStatistics.clear();
        self.hasNull = ::std::option::Option::None;
        self.bytesOnDisk = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ColumnStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColumnStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowIndexEntry {
    // message fields
    pub positions: ::std::vec::Vec<u64>,
    pub statistics: ::protobuf::SingularPtrField<ColumnStatistics>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowIndexEntry {
    fn default() -> &'a RowIndexEntry {
        <RowIndexEntry as ::protobuf::Message>::default_instance()
    }
}

impl RowIndexEntry {
    pub fn new() -> RowIndexEntry {
        ::std::default::Default::default()
    }

    // repeated uint64 positions = 1;


    pub fn get_positions(&self) -> &[u64] {
        &self.positions
    }
    pub fn clear_positions(&mut self) {
        self.positions.clear();
    }

    // Param is passed by value, moved
    pub fn set_positions(&mut self, v: ::std::vec::Vec<u64>) {
        self.positions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_positions(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.positions
    }

    // Take field
    pub fn take_positions(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.positions, ::std::vec::Vec::new())
    }

    // optional .orc.proto.ColumnStatistics statistics = 2;


    pub fn get_statistics(&self) -> &ColumnStatistics {
        self.statistics.as_ref().unwrap_or_else(|| <ColumnStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_statistics(&mut self) {
        self.statistics.clear();
    }

    pub fn has_statistics(&self) -> bool {
        self.statistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statistics(&mut self, v: ColumnStatistics) {
        self.statistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statistics(&mut self) -> &mut ColumnStatistics {
        if self.statistics.is_none() {
            self.statistics.set_default();
        }
        self.statistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_statistics(&mut self) -> ColumnStatistics {
        self.statistics.take().unwrap_or_else(|| ColumnStatistics::new())
    }
}

impl ::protobuf::Message for RowIndexEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.statistics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.positions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statistics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.positions.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(1, &self.positions);
        }
        if let Some(ref v) = self.statistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.positions.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.positions))?;
            for v in &self.positions {
                os.write_uint64_no_tag(*v)?;
            };
        }
        if let Some(ref v) = self.statistics.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowIndexEntry {
        RowIndexEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "positions",
                |m: &RowIndexEntry| { &m.positions },
                |m: &mut RowIndexEntry| { &mut m.positions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColumnStatistics>>(
                "statistics",
                |m: &RowIndexEntry| { &m.statistics },
                |m: &mut RowIndexEntry| { &mut m.statistics },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowIndexEntry>(
                "RowIndexEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowIndexEntry {
        static instance: ::protobuf::rt::LazyV2<RowIndexEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowIndexEntry::new)
    }
}

impl ::protobuf::Clear for RowIndexEntry {
    fn clear(&mut self) {
        self.positions.clear();
        self.statistics.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowIndexEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowIndexEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowIndex {
    // message fields
    pub entry: ::protobuf::RepeatedField<RowIndexEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowIndex {
    fn default() -> &'a RowIndex {
        <RowIndex as ::protobuf::Message>::default_instance()
    }
}

impl RowIndex {
    pub fn new() -> RowIndex {
        ::std::default::Default::default()
    }

    // repeated .orc.proto.RowIndexEntry entry = 1;


    pub fn get_entry(&self) -> &[RowIndexEntry] {
        &self.entry
    }
    pub fn clear_entry(&mut self) {
        self.entry.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry(&mut self, v: ::protobuf::RepeatedField<RowIndexEntry>) {
        self.entry = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entry(&mut self) -> &mut ::protobuf::RepeatedField<RowIndexEntry> {
        &mut self.entry
    }

    // Take field
    pub fn take_entry(&mut self) -> ::protobuf::RepeatedField<RowIndexEntry> {
        ::std::mem::replace(&mut self.entry, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RowIndex {
    fn is_initialized(&self) -> bool {
        for v in &self.entry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entry {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowIndex {
        RowIndex::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RowIndexEntry>>(
                "entry",
                |m: &RowIndex| { &m.entry },
                |m: &mut RowIndex| { &mut m.entry },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowIndex>(
                "RowIndex",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowIndex {
        static instance: ::protobuf::rt::LazyV2<RowIndex> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowIndex::new)
    }
}

impl ::protobuf::Clear for RowIndex {
    fn clear(&mut self) {
        self.entry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowIndex {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BloomFilter {
    // message fields
    numHashFunctions: ::std::option::Option<u32>,
    pub bitset: ::std::vec::Vec<u64>,
    utf8bitset: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BloomFilter {
    fn default() -> &'a BloomFilter {
        <BloomFilter as ::protobuf::Message>::default_instance()
    }
}

impl BloomFilter {
    pub fn new() -> BloomFilter {
        ::std::default::Default::default()
    }

    // optional uint32 numHashFunctions = 1;


    pub fn get_numHashFunctions(&self) -> u32 {
        self.numHashFunctions.unwrap_or(0)
    }
    pub fn clear_numHashFunctions(&mut self) {
        self.numHashFunctions = ::std::option::Option::None;
    }

    pub fn has_numHashFunctions(&self) -> bool {
        self.numHashFunctions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numHashFunctions(&mut self, v: u32) {
        self.numHashFunctions = ::std::option::Option::Some(v);
    }

    // repeated fixed64 bitset = 2;


    pub fn get_bitset(&self) -> &[u64] {
        &self.bitset
    }
    pub fn clear_bitset(&mut self) {
        self.bitset.clear();
    }

    // Param is passed by value, moved
    pub fn set_bitset(&mut self, v: ::std::vec::Vec<u64>) {
        self.bitset = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bitset(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.bitset
    }

    // Take field
    pub fn take_bitset(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.bitset, ::std::vec::Vec::new())
    }

    // optional bytes utf8bitset = 3;


    pub fn get_utf8bitset(&self) -> &[u8] {
        match self.utf8bitset.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_utf8bitset(&mut self) {
        self.utf8bitset.clear();
    }

    pub fn has_utf8bitset(&self) -> bool {
        self.utf8bitset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_utf8bitset(&mut self, v: ::std::vec::Vec<u8>) {
        self.utf8bitset = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_utf8bitset(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.utf8bitset.is_none() {
            self.utf8bitset.set_default();
        }
        self.utf8bitset.as_mut().unwrap()
    }

    // Take field
    pub fn take_utf8bitset(&mut self) -> ::std::vec::Vec<u8> {
        self.utf8bitset.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BloomFilter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numHashFunctions = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.bitset)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.utf8bitset)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.numHashFunctions {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 9 * self.bitset.len() as u32;
        if let Some(ref v) = self.utf8bitset.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.numHashFunctions {
            os.write_uint32(1, v)?;
        }
        for v in &self.bitset {
            os.write_fixed64(2, *v)?;
        };
        if let Some(ref v) = self.utf8bitset.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BloomFilter {
        BloomFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "numHashFunctions",
                |m: &BloomFilter| { &m.numHashFunctions },
                |m: &mut BloomFilter| { &mut m.numHashFunctions },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "bitset",
                |m: &BloomFilter| { &m.bitset },
                |m: &mut BloomFilter| { &mut m.bitset },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "utf8bitset",
                |m: &BloomFilter| { &m.utf8bitset },
                |m: &mut BloomFilter| { &mut m.utf8bitset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BloomFilter>(
                "BloomFilter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BloomFilter {
        static instance: ::protobuf::rt::LazyV2<BloomFilter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BloomFilter::new)
    }
}

impl ::protobuf::Clear for BloomFilter {
    fn clear(&mut self) {
        self.numHashFunctions = ::std::option::Option::None;
        self.bitset.clear();
        self.utf8bitset.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BloomFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BloomFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BloomFilterIndex {
    // message fields
    pub bloomFilter: ::protobuf::RepeatedField<BloomFilter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BloomFilterIndex {
    fn default() -> &'a BloomFilterIndex {
        <BloomFilterIndex as ::protobuf::Message>::default_instance()
    }
}

impl BloomFilterIndex {
    pub fn new() -> BloomFilterIndex {
        ::std::default::Default::default()
    }

    // repeated .orc.proto.BloomFilter bloomFilter = 1;


    pub fn get_bloomFilter(&self) -> &[BloomFilter] {
        &self.bloomFilter
    }
    pub fn clear_bloomFilter(&mut self) {
        self.bloomFilter.clear();
    }

    // Param is passed by value, moved
    pub fn set_bloomFilter(&mut self, v: ::protobuf::RepeatedField<BloomFilter>) {
        self.bloomFilter = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bloomFilter(&mut self) -> &mut ::protobuf::RepeatedField<BloomFilter> {
        &mut self.bloomFilter
    }

    // Take field
    pub fn take_bloomFilter(&mut self) -> ::protobuf::RepeatedField<BloomFilter> {
        ::std::mem::replace(&mut self.bloomFilter, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BloomFilterIndex {
    fn is_initialized(&self) -> bool {
        for v in &self.bloomFilter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bloomFilter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.bloomFilter {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.bloomFilter {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BloomFilterIndex {
        BloomFilterIndex::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BloomFilter>>(
                "bloomFilter",
                |m: &BloomFilterIndex| { &m.bloomFilter },
                |m: &mut BloomFilterIndex| { &mut m.bloomFilter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BloomFilterIndex>(
                "BloomFilterIndex",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BloomFilterIndex {
        static instance: ::protobuf::rt::LazyV2<BloomFilterIndex> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BloomFilterIndex::new)
    }
}

impl ::protobuf::Clear for BloomFilterIndex {
    fn clear(&mut self) {
        self.bloomFilter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BloomFilterIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BloomFilterIndex {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Stream {
    // message fields
    kind: ::std::option::Option<Stream_Kind>,
    column: ::std::option::Option<u32>,
    length: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Stream {
    fn default() -> &'a Stream {
        <Stream as ::protobuf::Message>::default_instance()
    }
}

impl Stream {
    pub fn new() -> Stream {
        ::std::default::Default::default()
    }

    // optional .orc.proto.Stream.Kind kind = 1;


    pub fn get_kind(&self) -> Stream_Kind {
        self.kind.unwrap_or(Stream_Kind::PRESENT)
    }
    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: Stream_Kind) {
        self.kind = ::std::option::Option::Some(v);
    }

    // optional uint32 column = 2;


    pub fn get_column(&self) -> u32 {
        self.column.unwrap_or(0)
    }
    pub fn clear_column(&mut self) {
        self.column = ::std::option::Option::None;
    }

    pub fn has_column(&self) -> bool {
        self.column.is_some()
    }

    // Param is passed by value, moved
    pub fn set_column(&mut self, v: u32) {
        self.column = ::std::option::Option::Some(v);
    }

    // optional uint64 length = 3;


    pub fn get_length(&self) -> u64 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Stream {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.kind, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.column = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.kind {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.column {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.kind {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.column {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.length {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Stream {
        Stream::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Stream_Kind>>(
                "kind",
                |m: &Stream| { &m.kind },
                |m: &mut Stream| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "column",
                |m: &Stream| { &m.column },
                |m: &mut Stream| { &mut m.column },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "length",
                |m: &Stream| { &m.length },
                |m: &mut Stream| { &mut m.length },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Stream>(
                "Stream",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Stream {
        static instance: ::protobuf::rt::LazyV2<Stream> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Stream::new)
    }
}

impl ::protobuf::Clear for Stream {
    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.column = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Stream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Stream {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Stream_Kind {
    PRESENT = 0,
    DATA = 1,
    LENGTH = 2,
    DICTIONARY_DATA = 3,
    DICTIONARY_COUNT = 4,
    SECONDARY = 5,
    ROW_INDEX = 6,
    BLOOM_FILTER = 7,
    BLOOM_FILTER_UTF8 = 8,
}

impl ::protobuf::ProtobufEnum for Stream_Kind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Stream_Kind> {
        match value {
            0 => ::std::option::Option::Some(Stream_Kind::PRESENT),
            1 => ::std::option::Option::Some(Stream_Kind::DATA),
            2 => ::std::option::Option::Some(Stream_Kind::LENGTH),
            3 => ::std::option::Option::Some(Stream_Kind::DICTIONARY_DATA),
            4 => ::std::option::Option::Some(Stream_Kind::DICTIONARY_COUNT),
            5 => ::std::option::Option::Some(Stream_Kind::SECONDARY),
            6 => ::std::option::Option::Some(Stream_Kind::ROW_INDEX),
            7 => ::std::option::Option::Some(Stream_Kind::BLOOM_FILTER),
            8 => ::std::option::Option::Some(Stream_Kind::BLOOM_FILTER_UTF8),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Stream_Kind] = &[
            Stream_Kind::PRESENT,
            Stream_Kind::DATA,
            Stream_Kind::LENGTH,
            Stream_Kind::DICTIONARY_DATA,
            Stream_Kind::DICTIONARY_COUNT,
            Stream_Kind::SECONDARY,
            Stream_Kind::ROW_INDEX,
            Stream_Kind::BLOOM_FILTER,
            Stream_Kind::BLOOM_FILTER_UTF8,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Stream_Kind>("Stream.Kind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Stream_Kind {
}

impl ::std::default::Default for Stream_Kind {
    fn default() -> Self {
        Stream_Kind::PRESENT
    }
}

impl ::protobuf::reflect::ProtobufValue for Stream_Kind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ColumnEncoding {
    // message fields
    kind: ::std::option::Option<ColumnEncoding_Kind>,
    dictionarySize: ::std::option::Option<u32>,
    bloomEncoding: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ColumnEncoding {
    fn default() -> &'a ColumnEncoding {
        <ColumnEncoding as ::protobuf::Message>::default_instance()
    }
}

impl ColumnEncoding {
    pub fn new() -> ColumnEncoding {
        ::std::default::Default::default()
    }

    // optional .orc.proto.ColumnEncoding.Kind kind = 1;


    pub fn get_kind(&self) -> ColumnEncoding_Kind {
        self.kind.unwrap_or(ColumnEncoding_Kind::DIRECT)
    }
    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ColumnEncoding_Kind) {
        self.kind = ::std::option::Option::Some(v);
    }

    // optional uint32 dictionarySize = 2;


    pub fn get_dictionarySize(&self) -> u32 {
        self.dictionarySize.unwrap_or(0)
    }
    pub fn clear_dictionarySize(&mut self) {
        self.dictionarySize = ::std::option::Option::None;
    }

    pub fn has_dictionarySize(&self) -> bool {
        self.dictionarySize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dictionarySize(&mut self, v: u32) {
        self.dictionarySize = ::std::option::Option::Some(v);
    }

    // optional uint32 bloomEncoding = 3;


    pub fn get_bloomEncoding(&self) -> u32 {
        self.bloomEncoding.unwrap_or(0)
    }
    pub fn clear_bloomEncoding(&mut self) {
        self.bloomEncoding = ::std::option::Option::None;
    }

    pub fn has_bloomEncoding(&self) -> bool {
        self.bloomEncoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bloomEncoding(&mut self, v: u32) {
        self.bloomEncoding = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ColumnEncoding {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.kind, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dictionarySize = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bloomEncoding = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.kind {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.dictionarySize {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bloomEncoding {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.kind {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.dictionarySize {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bloomEncoding {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ColumnEncoding {
        ColumnEncoding::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ColumnEncoding_Kind>>(
                "kind",
                |m: &ColumnEncoding| { &m.kind },
                |m: &mut ColumnEncoding| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dictionarySize",
                |m: &ColumnEncoding| { &m.dictionarySize },
                |m: &mut ColumnEncoding| { &mut m.dictionarySize },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bloomEncoding",
                |m: &ColumnEncoding| { &m.bloomEncoding },
                |m: &mut ColumnEncoding| { &mut m.bloomEncoding },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ColumnEncoding>(
                "ColumnEncoding",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ColumnEncoding {
        static instance: ::protobuf::rt::LazyV2<ColumnEncoding> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ColumnEncoding::new)
    }
}

impl ::protobuf::Clear for ColumnEncoding {
    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.dictionarySize = ::std::option::Option::None;
        self.bloomEncoding = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ColumnEncoding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColumnEncoding {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ColumnEncoding_Kind {
    DIRECT = 0,
    DICTIONARY = 1,
    DIRECT_V2 = 2,
    DICTIONARY_V2 = 3,
}

impl ::protobuf::ProtobufEnum for ColumnEncoding_Kind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ColumnEncoding_Kind> {
        match value {
            0 => ::std::option::Option::Some(ColumnEncoding_Kind::DIRECT),
            1 => ::std::option::Option::Some(ColumnEncoding_Kind::DICTIONARY),
            2 => ::std::option::Option::Some(ColumnEncoding_Kind::DIRECT_V2),
            3 => ::std::option::Option::Some(ColumnEncoding_Kind::DICTIONARY_V2),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ColumnEncoding_Kind] = &[
            ColumnEncoding_Kind::DIRECT,
            ColumnEncoding_Kind::DICTIONARY,
            ColumnEncoding_Kind::DIRECT_V2,
            ColumnEncoding_Kind::DICTIONARY_V2,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ColumnEncoding_Kind>("ColumnEncoding.Kind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ColumnEncoding_Kind {
}

impl ::std::default::Default for ColumnEncoding_Kind {
    fn default() -> Self {
        ColumnEncoding_Kind::DIRECT
    }
}

impl ::protobuf::reflect::ProtobufValue for ColumnEncoding_Kind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StripeFooter {
    // message fields
    pub streams: ::protobuf::RepeatedField<Stream>,
    pub columns: ::protobuf::RepeatedField<ColumnEncoding>,
    writerTimezone: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StripeFooter {
    fn default() -> &'a StripeFooter {
        <StripeFooter as ::protobuf::Message>::default_instance()
    }
}

impl StripeFooter {
    pub fn new() -> StripeFooter {
        ::std::default::Default::default()
    }

    // repeated .orc.proto.Stream streams = 1;


    pub fn get_streams(&self) -> &[Stream] {
        &self.streams
    }
    pub fn clear_streams(&mut self) {
        self.streams.clear();
    }

    // Param is passed by value, moved
    pub fn set_streams(&mut self, v: ::protobuf::RepeatedField<Stream>) {
        self.streams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_streams(&mut self) -> &mut ::protobuf::RepeatedField<Stream> {
        &mut self.streams
    }

    // Take field
    pub fn take_streams(&mut self) -> ::protobuf::RepeatedField<Stream> {
        ::std::mem::replace(&mut self.streams, ::protobuf::RepeatedField::new())
    }

    // repeated .orc.proto.ColumnEncoding columns = 2;


    pub fn get_columns(&self) -> &[ColumnEncoding] {
        &self.columns
    }
    pub fn clear_columns(&mut self) {
        self.columns.clear();
    }

    // Param is passed by value, moved
    pub fn set_columns(&mut self, v: ::protobuf::RepeatedField<ColumnEncoding>) {
        self.columns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_columns(&mut self) -> &mut ::protobuf::RepeatedField<ColumnEncoding> {
        &mut self.columns
    }

    // Take field
    pub fn take_columns(&mut self) -> ::protobuf::RepeatedField<ColumnEncoding> {
        ::std::mem::replace(&mut self.columns, ::protobuf::RepeatedField::new())
    }

    // optional string writerTimezone = 3;


    pub fn get_writerTimezone(&self) -> &str {
        match self.writerTimezone.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_writerTimezone(&mut self) {
        self.writerTimezone.clear();
    }

    pub fn has_writerTimezone(&self) -> bool {
        self.writerTimezone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writerTimezone(&mut self, v: ::std::string::String) {
        self.writerTimezone = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_writerTimezone(&mut self) -> &mut ::std::string::String {
        if self.writerTimezone.is_none() {
            self.writerTimezone.set_default();
        }
        self.writerTimezone.as_mut().unwrap()
    }

    // Take field
    pub fn take_writerTimezone(&mut self) -> ::std::string::String {
        self.writerTimezone.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for StripeFooter {
    fn is_initialized(&self) -> bool {
        for v in &self.streams {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.columns {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.streams)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.columns)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.writerTimezone)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.streams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.columns {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.writerTimezone.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.streams {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.columns {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.writerTimezone.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StripeFooter {
        StripeFooter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stream>>(
                "streams",
                |m: &StripeFooter| { &m.streams },
                |m: &mut StripeFooter| { &mut m.streams },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColumnEncoding>>(
                "columns",
                |m: &StripeFooter| { &m.columns },
                |m: &mut StripeFooter| { &mut m.columns },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "writerTimezone",
                |m: &StripeFooter| { &m.writerTimezone },
                |m: &mut StripeFooter| { &mut m.writerTimezone },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StripeFooter>(
                "StripeFooter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StripeFooter {
        static instance: ::protobuf::rt::LazyV2<StripeFooter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StripeFooter::new)
    }
}

impl ::protobuf::Clear for StripeFooter {
    fn clear(&mut self) {
        self.streams.clear();
        self.columns.clear();
        self.writerTimezone.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StripeFooter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StripeFooter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type {
    // message fields
    kind: ::std::option::Option<Type_Kind>,
    pub subtypes: ::std::vec::Vec<u32>,
    pub fieldNames: ::protobuf::RepeatedField<::std::string::String>,
    maximumLength: ::std::option::Option<u32>,
    precision: ::std::option::Option<u32>,
    scale: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type {
    fn default() -> &'a Type {
        <Type as ::protobuf::Message>::default_instance()
    }
}

impl Type {
    pub fn new() -> Type {
        ::std::default::Default::default()
    }

    // optional .orc.proto.Type.Kind kind = 1;


    pub fn get_kind(&self) -> Type_Kind {
        self.kind.unwrap_or(Type_Kind::BOOLEAN)
    }
    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: Type_Kind) {
        self.kind = ::std::option::Option::Some(v);
    }

    // repeated uint32 subtypes = 2;


    pub fn get_subtypes(&self) -> &[u32] {
        &self.subtypes
    }
    pub fn clear_subtypes(&mut self) {
        self.subtypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_subtypes(&mut self, v: ::std::vec::Vec<u32>) {
        self.subtypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subtypes(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.subtypes
    }

    // Take field
    pub fn take_subtypes(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.subtypes, ::std::vec::Vec::new())
    }

    // repeated string fieldNames = 3;


    pub fn get_fieldNames(&self) -> &[::std::string::String] {
        &self.fieldNames
    }
    pub fn clear_fieldNames(&mut self) {
        self.fieldNames.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldNames(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.fieldNames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fieldNames(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.fieldNames
    }

    // Take field
    pub fn take_fieldNames(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.fieldNames, ::protobuf::RepeatedField::new())
    }

    // optional uint32 maximumLength = 4;


    pub fn get_maximumLength(&self) -> u32 {
        self.maximumLength.unwrap_or(0)
    }
    pub fn clear_maximumLength(&mut self) {
        self.maximumLength = ::std::option::Option::None;
    }

    pub fn has_maximumLength(&self) -> bool {
        self.maximumLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximumLength(&mut self, v: u32) {
        self.maximumLength = ::std::option::Option::Some(v);
    }

    // optional uint32 precision = 5;


    pub fn get_precision(&self) -> u32 {
        self.precision.unwrap_or(0)
    }
    pub fn clear_precision(&mut self) {
        self.precision = ::std::option::Option::None;
    }

    pub fn has_precision(&self) -> bool {
        self.precision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_precision(&mut self, v: u32) {
        self.precision = ::std::option::Option::Some(v);
    }

    // optional uint32 scale = 6;


    pub fn get_scale(&self) -> u32 {
        self.scale.unwrap_or(0)
    }
    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: u32) {
        self.scale = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Type {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.kind, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.subtypes)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.fieldNames)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maximumLength = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.precision = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scale = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.kind {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if !self.subtypes.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(2, &self.subtypes);
        }
        for value in &self.fieldNames {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.maximumLength {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.precision {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scale {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.kind {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if !self.subtypes.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.subtypes))?;
            for v in &self.subtypes {
                os.write_uint32_no_tag(*v)?;
            };
        }
        for v in &self.fieldNames {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.maximumLength {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.precision {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.scale {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type {
        Type::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Type_Kind>>(
                "kind",
                |m: &Type| { &m.kind },
                |m: &mut Type| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "subtypes",
                |m: &Type| { &m.subtypes },
                |m: &mut Type| { &mut m.subtypes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fieldNames",
                |m: &Type| { &m.fieldNames },
                |m: &mut Type| { &mut m.fieldNames },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "maximumLength",
                |m: &Type| { &m.maximumLength },
                |m: &mut Type| { &mut m.maximumLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "precision",
                |m: &Type| { &m.precision },
                |m: &mut Type| { &mut m.precision },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "scale",
                |m: &Type| { &m.scale },
                |m: &mut Type| { &mut m.scale },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Type>(
                "Type",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Type {
        static instance: ::protobuf::rt::LazyV2<Type> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Type::new)
    }
}

impl ::protobuf::Clear for Type {
    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.subtypes.clear();
        self.fieldNames.clear();
        self.maximumLength = ::std::option::Option::None;
        self.precision = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Type_Kind {
    BOOLEAN = 0,
    BYTE = 1,
    SHORT = 2,
    INT = 3,
    LONG = 4,
    FLOAT = 5,
    DOUBLE = 6,
    STRING = 7,
    BINARY = 8,
    TIMESTAMP = 9,
    LIST = 10,
    MAP = 11,
    STRUCT = 12,
    UNION = 13,
    DECIMAL = 14,
    DATE = 15,
    VARCHAR = 16,
    CHAR = 17,
}

impl ::protobuf::ProtobufEnum for Type_Kind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Type_Kind> {
        match value {
            0 => ::std::option::Option::Some(Type_Kind::BOOLEAN),
            1 => ::std::option::Option::Some(Type_Kind::BYTE),
            2 => ::std::option::Option::Some(Type_Kind::SHORT),
            3 => ::std::option::Option::Some(Type_Kind::INT),
            4 => ::std::option::Option::Some(Type_Kind::LONG),
            5 => ::std::option::Option::Some(Type_Kind::FLOAT),
            6 => ::std::option::Option::Some(Type_Kind::DOUBLE),
            7 => ::std::option::Option::Some(Type_Kind::STRING),
            8 => ::std::option::Option::Some(Type_Kind::BINARY),
            9 => ::std::option::Option::Some(Type_Kind::TIMESTAMP),
            10 => ::std::option::Option::Some(Type_Kind::LIST),
            11 => ::std::option::Option::Some(Type_Kind::MAP),
            12 => ::std::option::Option::Some(Type_Kind::STRUCT),
            13 => ::std::option::Option::Some(Type_Kind::UNION),
            14 => ::std::option::Option::Some(Type_Kind::DECIMAL),
            15 => ::std::option::Option::Some(Type_Kind::DATE),
            16 => ::std::option::Option::Some(Type_Kind::VARCHAR),
            17 => ::std::option::Option::Some(Type_Kind::CHAR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Type_Kind] = &[
            Type_Kind::BOOLEAN,
            Type_Kind::BYTE,
            Type_Kind::SHORT,
            Type_Kind::INT,
            Type_Kind::LONG,
            Type_Kind::FLOAT,
            Type_Kind::DOUBLE,
            Type_Kind::STRING,
            Type_Kind::BINARY,
            Type_Kind::TIMESTAMP,
            Type_Kind::LIST,
            Type_Kind::MAP,
            Type_Kind::STRUCT,
            Type_Kind::UNION,
            Type_Kind::DECIMAL,
            Type_Kind::DATE,
            Type_Kind::VARCHAR,
            Type_Kind::CHAR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Type_Kind>("Type.Kind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Type_Kind {
}

impl ::std::default::Default for Type_Kind {
    fn default() -> Self {
        Type_Kind::BOOLEAN
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_Kind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StripeInformation {
    // message fields
    offset: ::std::option::Option<u64>,
    indexLength: ::std::option::Option<u64>,
    dataLength: ::std::option::Option<u64>,
    footerLength: ::std::option::Option<u64>,
    numberOfRows: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StripeInformation {
    fn default() -> &'a StripeInformation {
        <StripeInformation as ::protobuf::Message>::default_instance()
    }
}

impl StripeInformation {
    pub fn new() -> StripeInformation {
        ::std::default::Default::default()
    }

    // optional uint64 offset = 1;


    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }
    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint64 indexLength = 2;


    pub fn get_indexLength(&self) -> u64 {
        self.indexLength.unwrap_or(0)
    }
    pub fn clear_indexLength(&mut self) {
        self.indexLength = ::std::option::Option::None;
    }

    pub fn has_indexLength(&self) -> bool {
        self.indexLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_indexLength(&mut self, v: u64) {
        self.indexLength = ::std::option::Option::Some(v);
    }

    // optional uint64 dataLength = 3;


    pub fn get_dataLength(&self) -> u64 {
        self.dataLength.unwrap_or(0)
    }
    pub fn clear_dataLength(&mut self) {
        self.dataLength = ::std::option::Option::None;
    }

    pub fn has_dataLength(&self) -> bool {
        self.dataLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataLength(&mut self, v: u64) {
        self.dataLength = ::std::option::Option::Some(v);
    }

    // optional uint64 footerLength = 4;


    pub fn get_footerLength(&self) -> u64 {
        self.footerLength.unwrap_or(0)
    }
    pub fn clear_footerLength(&mut self) {
        self.footerLength = ::std::option::Option::None;
    }

    pub fn has_footerLength(&self) -> bool {
        self.footerLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_footerLength(&mut self, v: u64) {
        self.footerLength = ::std::option::Option::Some(v);
    }

    // optional uint64 numberOfRows = 5;


    pub fn get_numberOfRows(&self) -> u64 {
        self.numberOfRows.unwrap_or(0)
    }
    pub fn clear_numberOfRows(&mut self) {
        self.numberOfRows = ::std::option::Option::None;
    }

    pub fn has_numberOfRows(&self) -> bool {
        self.numberOfRows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberOfRows(&mut self, v: u64) {
        self.numberOfRows = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StripeInformation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.indexLength = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dataLength = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.footerLength = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.numberOfRows = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.indexLength {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dataLength {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.footerLength {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numberOfRows {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.offset {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.indexLength {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.dataLength {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.footerLength {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.numberOfRows {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StripeInformation {
        StripeInformation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "offset",
                |m: &StripeInformation| { &m.offset },
                |m: &mut StripeInformation| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "indexLength",
                |m: &StripeInformation| { &m.indexLength },
                |m: &mut StripeInformation| { &mut m.indexLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "dataLength",
                |m: &StripeInformation| { &m.dataLength },
                |m: &mut StripeInformation| { &mut m.dataLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "footerLength",
                |m: &StripeInformation| { &m.footerLength },
                |m: &mut StripeInformation| { &mut m.footerLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "numberOfRows",
                |m: &StripeInformation| { &m.numberOfRows },
                |m: &mut StripeInformation| { &mut m.numberOfRows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StripeInformation>(
                "StripeInformation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StripeInformation {
        static instance: ::protobuf::rt::LazyV2<StripeInformation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StripeInformation::new)
    }
}

impl ::protobuf::Clear for StripeInformation {
    fn clear(&mut self) {
        self.offset = ::std::option::Option::None;
        self.indexLength = ::std::option::Option::None;
        self.dataLength = ::std::option::Option::None;
        self.footerLength = ::std::option::Option::None;
        self.numberOfRows = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StripeInformation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StripeInformation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserMetadataItem {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserMetadataItem {
    fn default() -> &'a UserMetadataItem {
        <UserMetadataItem as ::protobuf::Message>::default_instance()
    }
}

impl UserMetadataItem {
    pub fn new() -> UserMetadataItem {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        match self.value.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        self.value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UserMetadataItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserMetadataItem {
        UserMetadataItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &UserMetadataItem| { &m.name },
                |m: &mut UserMetadataItem| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &UserMetadataItem| { &m.value },
                |m: &mut UserMetadataItem| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserMetadataItem>(
                "UserMetadataItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserMetadataItem {
        static instance: ::protobuf::rt::LazyV2<UserMetadataItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserMetadataItem::new)
    }
}

impl ::protobuf::Clear for UserMetadataItem {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserMetadataItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserMetadataItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StripeStatistics {
    // message fields
    pub colStats: ::protobuf::RepeatedField<ColumnStatistics>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StripeStatistics {
    fn default() -> &'a StripeStatistics {
        <StripeStatistics as ::protobuf::Message>::default_instance()
    }
}

impl StripeStatistics {
    pub fn new() -> StripeStatistics {
        ::std::default::Default::default()
    }

    // repeated .orc.proto.ColumnStatistics colStats = 1;


    pub fn get_colStats(&self) -> &[ColumnStatistics] {
        &self.colStats
    }
    pub fn clear_colStats(&mut self) {
        self.colStats.clear();
    }

    // Param is passed by value, moved
    pub fn set_colStats(&mut self, v: ::protobuf::RepeatedField<ColumnStatistics>) {
        self.colStats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_colStats(&mut self) -> &mut ::protobuf::RepeatedField<ColumnStatistics> {
        &mut self.colStats
    }

    // Take field
    pub fn take_colStats(&mut self) -> ::protobuf::RepeatedField<ColumnStatistics> {
        ::std::mem::replace(&mut self.colStats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StripeStatistics {
    fn is_initialized(&self) -> bool {
        for v in &self.colStats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.colStats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.colStats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.colStats {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StripeStatistics {
        StripeStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColumnStatistics>>(
                "colStats",
                |m: &StripeStatistics| { &m.colStats },
                |m: &mut StripeStatistics| { &mut m.colStats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StripeStatistics>(
                "StripeStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StripeStatistics {
        static instance: ::protobuf::rt::LazyV2<StripeStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StripeStatistics::new)
    }
}

impl ::protobuf::Clear for StripeStatistics {
    fn clear(&mut self) {
        self.colStats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StripeStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StripeStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Metadata {
    // message fields
    pub stripeStats: ::protobuf::RepeatedField<StripeStatistics>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Metadata {
    fn default() -> &'a Metadata {
        <Metadata as ::protobuf::Message>::default_instance()
    }
}

impl Metadata {
    pub fn new() -> Metadata {
        ::std::default::Default::default()
    }

    // repeated .orc.proto.StripeStatistics stripeStats = 1;


    pub fn get_stripeStats(&self) -> &[StripeStatistics] {
        &self.stripeStats
    }
    pub fn clear_stripeStats(&mut self) {
        self.stripeStats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stripeStats(&mut self, v: ::protobuf::RepeatedField<StripeStatistics>) {
        self.stripeStats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stripeStats(&mut self) -> &mut ::protobuf::RepeatedField<StripeStatistics> {
        &mut self.stripeStats
    }

    // Take field
    pub fn take_stripeStats(&mut self) -> ::protobuf::RepeatedField<StripeStatistics> {
        ::std::mem::replace(&mut self.stripeStats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Metadata {
    fn is_initialized(&self) -> bool {
        for v in &self.stripeStats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stripeStats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.stripeStats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.stripeStats {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Metadata {
        Metadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StripeStatistics>>(
                "stripeStats",
                |m: &Metadata| { &m.stripeStats },
                |m: &mut Metadata| { &mut m.stripeStats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Metadata>(
                "Metadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Metadata {
        static instance: ::protobuf::rt::LazyV2<Metadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Metadata::new)
    }
}

impl ::protobuf::Clear for Metadata {
    fn clear(&mut self) {
        self.stripeStats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Metadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Metadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Footer {
    // message fields
    headerLength: ::std::option::Option<u64>,
    contentLength: ::std::option::Option<u64>,
    pub stripes: ::protobuf::RepeatedField<StripeInformation>,
    pub types: ::protobuf::RepeatedField<Type>,
    pub metadata: ::protobuf::RepeatedField<UserMetadataItem>,
    numberOfRows: ::std::option::Option<u64>,
    pub statistics: ::protobuf::RepeatedField<ColumnStatistics>,
    rowIndexStride: ::std::option::Option<u32>,
    writer: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Footer {
    fn default() -> &'a Footer {
        <Footer as ::protobuf::Message>::default_instance()
    }
}

impl Footer {
    pub fn new() -> Footer {
        ::std::default::Default::default()
    }

    // optional uint64 headerLength = 1;


    pub fn get_headerLength(&self) -> u64 {
        self.headerLength.unwrap_or(0)
    }
    pub fn clear_headerLength(&mut self) {
        self.headerLength = ::std::option::Option::None;
    }

    pub fn has_headerLength(&self) -> bool {
        self.headerLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headerLength(&mut self, v: u64) {
        self.headerLength = ::std::option::Option::Some(v);
    }

    // optional uint64 contentLength = 2;


    pub fn get_contentLength(&self) -> u64 {
        self.contentLength.unwrap_or(0)
    }
    pub fn clear_contentLength(&mut self) {
        self.contentLength = ::std::option::Option::None;
    }

    pub fn has_contentLength(&self) -> bool {
        self.contentLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contentLength(&mut self, v: u64) {
        self.contentLength = ::std::option::Option::Some(v);
    }

    // repeated .orc.proto.StripeInformation stripes = 3;


    pub fn get_stripes(&self) -> &[StripeInformation] {
        &self.stripes
    }
    pub fn clear_stripes(&mut self) {
        self.stripes.clear();
    }

    // Param is passed by value, moved
    pub fn set_stripes(&mut self, v: ::protobuf::RepeatedField<StripeInformation>) {
        self.stripes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stripes(&mut self) -> &mut ::protobuf::RepeatedField<StripeInformation> {
        &mut self.stripes
    }

    // Take field
    pub fn take_stripes(&mut self) -> ::protobuf::RepeatedField<StripeInformation> {
        ::std::mem::replace(&mut self.stripes, ::protobuf::RepeatedField::new())
    }

    // repeated .orc.proto.Type types = 4;


    pub fn get_types(&self) -> &[Type] {
        &self.types
    }
    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.types, ::protobuf::RepeatedField::new())
    }

    // repeated .orc.proto.UserMetadataItem metadata = 5;


    pub fn get_metadata(&self) -> &[UserMetadataItem] {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::RepeatedField<UserMetadataItem>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::RepeatedField<UserMetadataItem> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::RepeatedField<UserMetadataItem> {
        ::std::mem::replace(&mut self.metadata, ::protobuf::RepeatedField::new())
    }

    // optional uint64 numberOfRows = 6;


    pub fn get_numberOfRows(&self) -> u64 {
        self.numberOfRows.unwrap_or(0)
    }
    pub fn clear_numberOfRows(&mut self) {
        self.numberOfRows = ::std::option::Option::None;
    }

    pub fn has_numberOfRows(&self) -> bool {
        self.numberOfRows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberOfRows(&mut self, v: u64) {
        self.numberOfRows = ::std::option::Option::Some(v);
    }

    // repeated .orc.proto.ColumnStatistics statistics = 7;


    pub fn get_statistics(&self) -> &[ColumnStatistics] {
        &self.statistics
    }
    pub fn clear_statistics(&mut self) {
        self.statistics.clear();
    }

    // Param is passed by value, moved
    pub fn set_statistics(&mut self, v: ::protobuf::RepeatedField<ColumnStatistics>) {
        self.statistics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statistics(&mut self) -> &mut ::protobuf::RepeatedField<ColumnStatistics> {
        &mut self.statistics
    }

    // Take field
    pub fn take_statistics(&mut self) -> ::protobuf::RepeatedField<ColumnStatistics> {
        ::std::mem::replace(&mut self.statistics, ::protobuf::RepeatedField::new())
    }

    // optional uint32 rowIndexStride = 8;


    pub fn get_rowIndexStride(&self) -> u32 {
        self.rowIndexStride.unwrap_or(0)
    }
    pub fn clear_rowIndexStride(&mut self) {
        self.rowIndexStride = ::std::option::Option::None;
    }

    pub fn has_rowIndexStride(&self) -> bool {
        self.rowIndexStride.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rowIndexStride(&mut self, v: u32) {
        self.rowIndexStride = ::std::option::Option::Some(v);
    }

    // optional uint32 writer = 9;


    pub fn get_writer(&self) -> u32 {
        self.writer.unwrap_or(0)
    }
    pub fn clear_writer(&mut self) {
        self.writer = ::std::option::Option::None;
    }

    pub fn has_writer(&self) -> bool {
        self.writer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writer(&mut self, v: u32) {
        self.writer = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Footer {
    fn is_initialized(&self) -> bool {
        for v in &self.stripes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.types {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statistics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.headerLength = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.contentLength = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stripes)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.types)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metadata)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.numberOfRows = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statistics)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rowIndexStride = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.writer = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.headerLength {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.contentLength {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.stripes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.numberOfRows {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.statistics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.rowIndexStride {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.writer {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.headerLength {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.contentLength {
            os.write_uint64(2, v)?;
        }
        for v in &self.stripes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.types {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.metadata {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.numberOfRows {
            os.write_uint64(6, v)?;
        }
        for v in &self.statistics {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.rowIndexStride {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.writer {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Footer {
        Footer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "headerLength",
                |m: &Footer| { &m.headerLength },
                |m: &mut Footer| { &mut m.headerLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "contentLength",
                |m: &Footer| { &m.contentLength },
                |m: &mut Footer| { &mut m.contentLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StripeInformation>>(
                "stripes",
                |m: &Footer| { &m.stripes },
                |m: &mut Footer| { &mut m.stripes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                "types",
                |m: &Footer| { &m.types },
                |m: &mut Footer| { &mut m.types },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserMetadataItem>>(
                "metadata",
                |m: &Footer| { &m.metadata },
                |m: &mut Footer| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "numberOfRows",
                |m: &Footer| { &m.numberOfRows },
                |m: &mut Footer| { &mut m.numberOfRows },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColumnStatistics>>(
                "statistics",
                |m: &Footer| { &m.statistics },
                |m: &mut Footer| { &mut m.statistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rowIndexStride",
                |m: &Footer| { &m.rowIndexStride },
                |m: &mut Footer| { &mut m.rowIndexStride },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "writer",
                |m: &Footer| { &m.writer },
                |m: &mut Footer| { &mut m.writer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Footer>(
                "Footer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Footer {
        static instance: ::protobuf::rt::LazyV2<Footer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Footer::new)
    }
}

impl ::protobuf::Clear for Footer {
    fn clear(&mut self) {
        self.headerLength = ::std::option::Option::None;
        self.contentLength = ::std::option::Option::None;
        self.stripes.clear();
        self.types.clear();
        self.metadata.clear();
        self.numberOfRows = ::std::option::Option::None;
        self.statistics.clear();
        self.rowIndexStride = ::std::option::Option::None;
        self.writer = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Footer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Footer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostScript {
    // message fields
    footerLength: ::std::option::Option<u64>,
    compression: ::std::option::Option<CompressionKind>,
    compressionBlockSize: ::std::option::Option<u64>,
    pub version: ::std::vec::Vec<u32>,
    metadataLength: ::std::option::Option<u64>,
    writerVersion: ::std::option::Option<u32>,
    magic: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostScript {
    fn default() -> &'a PostScript {
        <PostScript as ::protobuf::Message>::default_instance()
    }
}

impl PostScript {
    pub fn new() -> PostScript {
        ::std::default::Default::default()
    }

    // optional uint64 footerLength = 1;


    pub fn get_footerLength(&self) -> u64 {
        self.footerLength.unwrap_or(0)
    }
    pub fn clear_footerLength(&mut self) {
        self.footerLength = ::std::option::Option::None;
    }

    pub fn has_footerLength(&self) -> bool {
        self.footerLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_footerLength(&mut self, v: u64) {
        self.footerLength = ::std::option::Option::Some(v);
    }

    // optional .orc.proto.CompressionKind compression = 2;


    pub fn get_compression(&self) -> CompressionKind {
        self.compression.unwrap_or(CompressionKind::NONE)
    }
    pub fn clear_compression(&mut self) {
        self.compression = ::std::option::Option::None;
    }

    pub fn has_compression(&self) -> bool {
        self.compression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compression(&mut self, v: CompressionKind) {
        self.compression = ::std::option::Option::Some(v);
    }

    // optional uint64 compressionBlockSize = 3;


    pub fn get_compressionBlockSize(&self) -> u64 {
        self.compressionBlockSize.unwrap_or(0)
    }
    pub fn clear_compressionBlockSize(&mut self) {
        self.compressionBlockSize = ::std::option::Option::None;
    }

    pub fn has_compressionBlockSize(&self) -> bool {
        self.compressionBlockSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compressionBlockSize(&mut self, v: u64) {
        self.compressionBlockSize = ::std::option::Option::Some(v);
    }

    // repeated uint32 version = 4;


    pub fn get_version(&self) -> &[u32] {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::vec::Vec<u32>) {
        self.version = v;
    }

    // Mutable pointer to the field.
    pub fn mut_version(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.version, ::std::vec::Vec::new())
    }

    // optional uint64 metadataLength = 5;


    pub fn get_metadataLength(&self) -> u64 {
        self.metadataLength.unwrap_or(0)
    }
    pub fn clear_metadataLength(&mut self) {
        self.metadataLength = ::std::option::Option::None;
    }

    pub fn has_metadataLength(&self) -> bool {
        self.metadataLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadataLength(&mut self, v: u64) {
        self.metadataLength = ::std::option::Option::Some(v);
    }

    // optional uint32 writerVersion = 6;


    pub fn get_writerVersion(&self) -> u32 {
        self.writerVersion.unwrap_or(0)
    }
    pub fn clear_writerVersion(&mut self) {
        self.writerVersion = ::std::option::Option::None;
    }

    pub fn has_writerVersion(&self) -> bool {
        self.writerVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writerVersion(&mut self, v: u32) {
        self.writerVersion = ::std::option::Option::Some(v);
    }

    // optional string magic = 8000;


    pub fn get_magic(&self) -> &str {
        match self.magic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_magic(&mut self) {
        self.magic.clear();
    }

    pub fn has_magic(&self) -> bool {
        self.magic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magic(&mut self, v: ::std::string::String) {
        self.magic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_magic(&mut self) -> &mut ::std::string::String {
        if self.magic.is_none() {
            self.magic.set_default();
        }
        self.magic.as_mut().unwrap()
    }

    // Take field
    pub fn take_magic(&mut self) -> ::std::string::String {
        self.magic.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PostScript {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.footerLength = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.compression, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.compressionBlockSize = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.version)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.metadataLength = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.writerVersion = ::std::option::Option::Some(tmp);
                },
                8000 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.magic)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.footerLength {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.compression {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.compressionBlockSize {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(4, &self.version);
        }
        if let Some(v) = self.metadataLength {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.writerVersion {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.magic.as_ref() {
            my_size += ::protobuf::rt::string_size(8000, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.footerLength {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.compression {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.compressionBlockSize {
            os.write_uint64(3, v)?;
        }
        if !self.version.is_empty() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.version))?;
            for v in &self.version {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if let Some(v) = self.metadataLength {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.writerVersion {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.magic.as_ref() {
            os.write_string(8000, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostScript {
        PostScript::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "footerLength",
                |m: &PostScript| { &m.footerLength },
                |m: &mut PostScript| { &mut m.footerLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CompressionKind>>(
                "compression",
                |m: &PostScript| { &m.compression },
                |m: &mut PostScript| { &mut m.compression },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "compressionBlockSize",
                |m: &PostScript| { &m.compressionBlockSize },
                |m: &mut PostScript| { &mut m.compressionBlockSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version",
                |m: &PostScript| { &m.version },
                |m: &mut PostScript| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "metadataLength",
                |m: &PostScript| { &m.metadataLength },
                |m: &mut PostScript| { &mut m.metadataLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "writerVersion",
                |m: &PostScript| { &m.writerVersion },
                |m: &mut PostScript| { &mut m.writerVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "magic",
                |m: &PostScript| { &m.magic },
                |m: &mut PostScript| { &mut m.magic },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostScript>(
                "PostScript",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostScript {
        static instance: ::protobuf::rt::LazyV2<PostScript> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostScript::new)
    }
}

impl ::protobuf::Clear for PostScript {
    fn clear(&mut self) {
        self.footerLength = ::std::option::Option::None;
        self.compression = ::std::option::Option::None;
        self.compressionBlockSize = ::std::option::Option::None;
        self.version.clear();
        self.metadataLength = ::std::option::Option::None;
        self.writerVersion = ::std::option::Option::None;
        self.magic.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostScript {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostScript {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileTail {
    // message fields
    pub postscript: ::protobuf::SingularPtrField<PostScript>,
    pub footer: ::protobuf::SingularPtrField<Footer>,
    fileLength: ::std::option::Option<u64>,
    postscriptLength: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileTail {
    fn default() -> &'a FileTail {
        <FileTail as ::protobuf::Message>::default_instance()
    }
}

impl FileTail {
    pub fn new() -> FileTail {
        ::std::default::Default::default()
    }

    // optional .orc.proto.PostScript postscript = 1;


    pub fn get_postscript(&self) -> &PostScript {
        self.postscript.as_ref().unwrap_or_else(|| <PostScript as ::protobuf::Message>::default_instance())
    }
    pub fn clear_postscript(&mut self) {
        self.postscript.clear();
    }

    pub fn has_postscript(&self) -> bool {
        self.postscript.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postscript(&mut self, v: PostScript) {
        self.postscript = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postscript(&mut self) -> &mut PostScript {
        if self.postscript.is_none() {
            self.postscript.set_default();
        }
        self.postscript.as_mut().unwrap()
    }

    // Take field
    pub fn take_postscript(&mut self) -> PostScript {
        self.postscript.take().unwrap_or_else(|| PostScript::new())
    }

    // optional .orc.proto.Footer footer = 2;


    pub fn get_footer(&self) -> &Footer {
        self.footer.as_ref().unwrap_or_else(|| <Footer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_footer(&mut self) {
        self.footer.clear();
    }

    pub fn has_footer(&self) -> bool {
        self.footer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_footer(&mut self, v: Footer) {
        self.footer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_footer(&mut self) -> &mut Footer {
        if self.footer.is_none() {
            self.footer.set_default();
        }
        self.footer.as_mut().unwrap()
    }

    // Take field
    pub fn take_footer(&mut self) -> Footer {
        self.footer.take().unwrap_or_else(|| Footer::new())
    }

    // optional uint64 fileLength = 3;


    pub fn get_fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }
    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional uint64 postscriptLength = 4;


    pub fn get_postscriptLength(&self) -> u64 {
        self.postscriptLength.unwrap_or(0)
    }
    pub fn clear_postscriptLength(&mut self) {
        self.postscriptLength = ::std::option::Option::None;
    }

    pub fn has_postscriptLength(&self) -> bool {
        self.postscriptLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postscriptLength(&mut self, v: u64) {
        self.postscriptLength = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for FileTail {
    fn is_initialized(&self) -> bool {
        for v in &self.postscript {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.footer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postscript)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.footer)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileLength = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.postscriptLength = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.postscript.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.footer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.postscriptLength {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.postscript.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.footer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.postscriptLength {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileTail {
        FileTail::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PostScript>>(
                "postscript",
                |m: &FileTail| { &m.postscript },
                |m: &mut FileTail| { &mut m.postscript },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Footer>>(
                "footer",
                |m: &FileTail| { &m.footer },
                |m: &mut FileTail| { &mut m.footer },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fileLength",
                |m: &FileTail| { &m.fileLength },
                |m: &mut FileTail| { &mut m.fileLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "postscriptLength",
                |m: &FileTail| { &m.postscriptLength },
                |m: &mut FileTail| { &mut m.postscriptLength },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileTail>(
                "FileTail",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FileTail {
        static instance: ::protobuf::rt::LazyV2<FileTail> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FileTail::new)
    }
}

impl ::protobuf::Clear for FileTail {
    fn clear(&mut self) {
        self.postscript.clear();
        self.footer.clear();
        self.fileLength = ::std::option::Option::None;
        self.postscriptLength = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileTail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTail {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CompressionKind {
    NONE = 0,
    ZLIB = 1,
    SNAPPY = 2,
    LZO = 3,
    LZ4 = 4,
    ZSTD = 5,
}

impl ::protobuf::ProtobufEnum for CompressionKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CompressionKind> {
        match value {
            0 => ::std::option::Option::Some(CompressionKind::NONE),
            1 => ::std::option::Option::Some(CompressionKind::ZLIB),
            2 => ::std::option::Option::Some(CompressionKind::SNAPPY),
            3 => ::std::option::Option::Some(CompressionKind::LZO),
            4 => ::std::option::Option::Some(CompressionKind::LZ4),
            5 => ::std::option::Option::Some(CompressionKind::ZSTD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CompressionKind] = &[
            CompressionKind::NONE,
            CompressionKind::ZLIB,
            CompressionKind::SNAPPY,
            CompressionKind::LZO,
            CompressionKind::LZ4,
            CompressionKind::ZSTD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CompressionKind>("CompressionKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CompressionKind {
}

impl ::std::default::Default for CompressionKind {
    fn default() -> Self {
        CompressionKind::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for CompressionKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0forc_proto.proto\x12\torc.proto\"Y\n\x11IntegerStatistics\x12\x18\n\
    \x07minimum\x18\x01\x20\x01(\x12R\x07minimum\x12\x18\n\x07maximum\x18\
    \x02\x20\x01(\x12R\x07maximum\x12\x10\n\x03sum\x18\x03\x20\x01(\x12R\x03\
    sum\"X\n\x10DoubleStatistics\x12\x18\n\x07minimum\x18\x01\x20\x01(\x01R\
    \x07minimum\x12\x18\n\x07maximum\x18\x02\x20\x01(\x01R\x07maximum\x12\
    \x10\n\x03sum\x18\x03\x20\x01(\x01R\x03sum\"X\n\x10StringStatistics\x12\
    \x18\n\x07minimum\x18\x01\x20\x01(\tR\x07minimum\x12\x18\n\x07maximum\
    \x18\x02\x20\x01(\tR\x07maximum\x12\x10\n\x03sum\x18\x03\x20\x01(\x12R\
    \x03sum\",\n\x10BucketStatistics\x12\x18\n\x05count\x18\x01\x20\x03(\x04\
    R\x05countB\x02\x10\x01\"Y\n\x11DecimalStatistics\x12\x18\n\x07minimum\
    \x18\x01\x20\x01(\tR\x07minimum\x12\x18\n\x07maximum\x18\x02\x20\x01(\tR\
    \x07maximum\x12\x10\n\x03sum\x18\x03\x20\x01(\tR\x03sum\"D\n\x0eDateStat\
    istics\x12\x18\n\x07minimum\x18\x01\x20\x01(\x11R\x07minimum\x12\x18\n\
    \x07maximum\x18\x02\x20\x01(\x11R\x07maximum\"\x89\x01\n\x13TimestampSta\
    tistics\x12\x18\n\x07minimum\x18\x01\x20\x01(\x12R\x07minimum\x12\x18\n\
    \x07maximum\x18\x02\x20\x01(\x12R\x07maximum\x12\x1e\n\nminimumUtc\x18\
    \x03\x20\x01(\x12R\nminimumUtc\x12\x1e\n\nmaximumUtc\x18\x04\x20\x01(\
    \x12R\nmaximumUtc\"$\n\x10BinaryStatistics\x12\x10\n\x03sum\x18\x01\x20\
    \x01(\x12R\x03sum\"\xbf\x05\n\x10ColumnStatistics\x12&\n\x0enumberOfValu\
    es\x18\x01\x20\x01(\x04R\x0enumberOfValues\x12B\n\rintStatistics\x18\x02\
    \x20\x01(\x0b2\x1c.orc.proto.IntegerStatisticsR\rintStatistics\x12G\n\
    \x10doubleStatistics\x18\x03\x20\x01(\x0b2\x1b.orc.proto.DoubleStatistic\
    sR\x10doubleStatistics\x12G\n\x10stringStatistics\x18\x04\x20\x01(\x0b2\
    \x1b.orc.proto.StringStatisticsR\x10stringStatistics\x12G\n\x10bucketSta\
    tistics\x18\x05\x20\x01(\x0b2\x1b.orc.proto.BucketStatisticsR\x10bucketS\
    tatistics\x12J\n\x11decimalStatistics\x18\x06\x20\x01(\x0b2\x1c.orc.prot\
    o.DecimalStatisticsR\x11decimalStatistics\x12A\n\x0edateStatistics\x18\
    \x07\x20\x01(\x0b2\x19.orc.proto.DateStatisticsR\x0edateStatistics\x12G\
    \n\x10binaryStatistics\x18\x08\x20\x01(\x0b2\x1b.orc.proto.BinaryStatist\
    icsR\x10binaryStatistics\x12P\n\x13timestampStatistics\x18\t\x20\x01(\
    \x0b2\x1e.orc.proto.TimestampStatisticsR\x13timestampStatistics\x12\x18\
    \n\x07hasNull\x18\n\x20\x01(\x08R\x07hasNull\x12\x20\n\x0bbytesOnDisk\
    \x18\x0b\x20\x01(\x04R\x0bbytesOnDisk\"n\n\rRowIndexEntry\x12\x20\n\tpos\
    itions\x18\x01\x20\x03(\x04R\tpositionsB\x02\x10\x01\x12;\n\nstatistics\
    \x18\x02\x20\x01(\x0b2\x1b.orc.proto.ColumnStatisticsR\nstatistics\":\n\
    \x08RowIndex\x12.\n\x05entry\x18\x01\x20\x03(\x0b2\x18.orc.proto.RowInde\
    xEntryR\x05entry\"q\n\x0bBloomFilter\x12*\n\x10numHashFunctions\x18\x01\
    \x20\x01(\rR\x10numHashFunctions\x12\x16\n\x06bitset\x18\x02\x20\x03(\
    \x06R\x06bitset\x12\x1e\n\nutf8bitset\x18\x03\x20\x01(\x0cR\nutf8bitset\
    \"L\n\x10BloomFilterIndex\x128\n\x0bbloomFilter\x18\x01\x20\x03(\x0b2\
    \x16.orc.proto.BloomFilterR\x0bbloomFilter\"\x82\x02\n\x06Stream\x12*\n\
    \x04kind\x18\x01\x20\x01(\x0e2\x16.orc.proto.Stream.KindR\x04kind\x12\
    \x16\n\x06column\x18\x02\x20\x01(\rR\x06column\x12\x16\n\x06length\x18\
    \x03\x20\x01(\x04R\x06length\"\x9b\x01\n\x04Kind\x12\x0b\n\x07PRESENT\
    \x10\0\x12\x08\n\x04DATA\x10\x01\x12\n\n\x06LENGTH\x10\x02\x12\x13\n\x0f\
    DICTIONARY_DATA\x10\x03\x12\x14\n\x10DICTIONARY_COUNT\x10\x04\x12\r\n\tS\
    ECONDARY\x10\x05\x12\r\n\tROW_INDEX\x10\x06\x12\x10\n\x0cBLOOM_FILTER\
    \x10\x07\x12\x15\n\x11BLOOM_FILTER_UTF8\x10\x08\"\xd8\x01\n\x0eColumnEnc\
    oding\x122\n\x04kind\x18\x01\x20\x01(\x0e2\x1e.orc.proto.ColumnEncoding.\
    KindR\x04kind\x12&\n\x0edictionarySize\x18\x02\x20\x01(\rR\x0edictionary\
    Size\x12$\n\rbloomEncoding\x18\x03\x20\x01(\rR\rbloomEncoding\"D\n\x04Ki\
    nd\x12\n\n\x06DIRECT\x10\0\x12\x0e\n\nDICTIONARY\x10\x01\x12\r\n\tDIRECT\
    _V2\x10\x02\x12\x11\n\rDICTIONARY_V2\x10\x03\"\x98\x01\n\x0cStripeFooter\
    \x12+\n\x07streams\x18\x01\x20\x03(\x0b2\x11.orc.proto.StreamR\x07stream\
    s\x123\n\x07columns\x18\x02\x20\x03(\x0b2\x19.orc.proto.ColumnEncodingR\
    \x07columns\x12&\n\x0ewriterTimezone\x18\x03\x20\x01(\tR\x0ewriterTimezo\
    ne\"\x9e\x03\n\x04Type\x12(\n\x04kind\x18\x01\x20\x01(\x0e2\x14.orc.prot\
    o.Type.KindR\x04kind\x12\x1e\n\x08subtypes\x18\x02\x20\x03(\rR\x08subtyp\
    esB\x02\x10\x01\x12\x1e\n\nfieldNames\x18\x03\x20\x03(\tR\nfieldNames\
    \x12$\n\rmaximumLength\x18\x04\x20\x01(\rR\rmaximumLength\x12\x1c\n\tpre\
    cision\x18\x05\x20\x01(\rR\tprecision\x12\x14\n\x05scale\x18\x06\x20\x01\
    (\rR\x05scale\"\xd1\x01\n\x04Kind\x12\x0b\n\x07BOOLEAN\x10\0\x12\x08\n\
    \x04BYTE\x10\x01\x12\t\n\x05SHORT\x10\x02\x12\x07\n\x03INT\x10\x03\x12\
    \x08\n\x04LONG\x10\x04\x12\t\n\x05FLOAT\x10\x05\x12\n\n\x06DOUBLE\x10\
    \x06\x12\n\n\x06STRING\x10\x07\x12\n\n\x06BINARY\x10\x08\x12\r\n\tTIMEST\
    AMP\x10\t\x12\x08\n\x04LIST\x10\n\x12\x07\n\x03MAP\x10\x0b\x12\n\n\x06ST\
    RUCT\x10\x0c\x12\t\n\x05UNION\x10\r\x12\x0b\n\x07DECIMAL\x10\x0e\x12\x08\
    \n\x04DATE\x10\x0f\x12\x0b\n\x07VARCHAR\x10\x10\x12\x08\n\x04CHAR\x10\
    \x11\"\xb5\x01\n\x11StripeInformation\x12\x16\n\x06offset\x18\x01\x20\
    \x01(\x04R\x06offset\x12\x20\n\x0bindexLength\x18\x02\x20\x01(\x04R\x0bi\
    ndexLength\x12\x1e\n\ndataLength\x18\x03\x20\x01(\x04R\ndataLength\x12\"\
    \n\x0cfooterLength\x18\x04\x20\x01(\x04R\x0cfooterLength\x12\"\n\x0cnumb\
    erOfRows\x18\x05\x20\x01(\x04R\x0cnumberOfRows\"<\n\x10UserMetadataItem\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\
    \x02\x20\x01(\x0cR\x05value\"K\n\x10StripeStatistics\x127\n\x08colStats\
    \x18\x01\x20\x03(\x0b2\x1b.orc.proto.ColumnStatisticsR\x08colStats\"I\n\
    \x08Metadata\x12=\n\x0bstripeStats\x18\x01\x20\x03(\x0b2\x1b.orc.proto.S\
    tripeStatisticsR\x0bstripeStats\"\x8b\x03\n\x06Footer\x12\"\n\x0cheaderL\
    ength\x18\x01\x20\x01(\x04R\x0cheaderLength\x12$\n\rcontentLength\x18\
    \x02\x20\x01(\x04R\rcontentLength\x126\n\x07stripes\x18\x03\x20\x03(\x0b\
    2\x1c.orc.proto.StripeInformationR\x07stripes\x12%\n\x05types\x18\x04\
    \x20\x03(\x0b2\x0f.orc.proto.TypeR\x05types\x127\n\x08metadata\x18\x05\
    \x20\x03(\x0b2\x1b.orc.proto.UserMetadataItemR\x08metadata\x12\"\n\x0cnu\
    mberOfRows\x18\x06\x20\x01(\x04R\x0cnumberOfRows\x12;\n\nstatistics\x18\
    \x07\x20\x03(\x0b2\x1b.orc.proto.ColumnStatisticsR\nstatistics\x12&\n\
    \x0erowIndexStride\x18\x08\x20\x01(\rR\x0erowIndexStride\x12\x16\n\x06wr\
    iter\x18\t\x20\x01(\rR\x06writer\"\xa5\x02\n\nPostScript\x12\"\n\x0cfoot\
    erLength\x18\x01\x20\x01(\x04R\x0cfooterLength\x12<\n\x0bcompression\x18\
    \x02\x20\x01(\x0e2\x1a.orc.proto.CompressionKindR\x0bcompression\x122\n\
    \x14compressionBlockSize\x18\x03\x20\x01(\x04R\x14compressionBlockSize\
    \x12\x1c\n\x07version\x18\x04\x20\x03(\rR\x07versionB\x02\x10\x01\x12&\n\
    \x0emetadataLength\x18\x05\x20\x01(\x04R\x0emetadataLength\x12$\n\rwrite\
    rVersion\x18\x06\x20\x01(\rR\rwriterVersion\x12\x15\n\x05magic\x18\xc0>\
    \x20\x01(\tR\x05magic\"\xb8\x01\n\x08FileTail\x125\n\npostscript\x18\x01\
    \x20\x01(\x0b2\x15.orc.proto.PostScriptR\npostscript\x12)\n\x06footer\
    \x18\x02\x20\x01(\x0b2\x11.orc.proto.FooterR\x06footer\x12\x1e\n\nfileLe\
    ngth\x18\x03\x20\x01(\x04R\nfileLength\x12*\n\x10postscriptLength\x18\
    \x04\x20\x01(\x04R\x10postscriptLength*M\n\x0fCompressionKind\x12\x08\n\
    \x04NONE\x10\0\x12\x08\n\x04ZLIB\x10\x01\x12\n\n\x06SNAPPY\x10\x02\x12\
    \x07\n\x03LZO\x10\x03\x12\x07\n\x03LZ4\x10\x04\x12\x08\n\x04ZSTD\x10\x05\
    B\x10\n\x0eorg.apache.orc\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
